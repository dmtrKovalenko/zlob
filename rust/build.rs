use std::env;
use std::fs;
use std::io::{BufRead, BufReader};
use std::path::PathBuf;
use std::process::Command;

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
    let zlob_root = manifest_dir.parent().unwrap(); // Go up from rust/ to zlob/

    // Parse C header and generate Rust constants
    generate_flags_from_header(zlob_root, &out_dir);

    let zig = env::var("ZIG").unwrap_or_else(|_| "zig".to_string());
    let zig_version = Command::new(&zig)
        .arg("version")
        .output()
        .expect("Failed to find zig. Please install zig or set the ZIG environment variable.");

    if !zig_version.status.success() {
        panic!("Failed to run zig. Please ensure zig is installed and accessible.");
    }

    let target = env::var("TARGET").unwrap();
    let host = env::var("HOST").unwrap();

    // Use "native" for host builds to avoid archive format issues with rust-lld.
    // When cross-compiling, Zig produces archives with SYM64 format that rust-lld
    // cannot parse, but native builds produce compatible archives.
    let zig_target = if target == host {
        "native"
    } else {
        rust_target_to_zig(&target)
    };

    let profile = env::var("PROFILE").unwrap();
    let optimize = match profile.as_str() {
        "release" | "bench" => "ReleaseFast",
        _ => "Debug",
    };

    // Build static library using zig build
    let mut cmd = Command::new(&zig);
    cmd.current_dir(zlob_root)
        .arg("build")
        .arg(format!("-Doptimize={}", optimize))
        .arg("-p")
        .arg(out_dir.as_os_str());

    // Only pass target if not native
    if zig_target != "native" {
        cmd.arg(format!("-Dtarget={}", zig_target));
    }

    println!("cargo:warning=Running: {:?}", cmd);

    // print the output of the zig build
    let output = cmd.output().expect("Failed to run zig build");
    if !output.status.success() {
        let stdout = String::from_utf8_lossy(&output.stdout);
        let stderr = String::from_utf8_lossy(&output.stderr);

        if !stdout.is_empty() {
            for line in stdout.lines() {
                println!("cargo:warning={}", line);
            }
        }
        if !stderr.is_empty() {
            for line in stderr.lines() {
                println!("cargo:warning={}", line);
            }
        }

        println!("cargo:warning=Command: {:?}", cmd);
        panic!("zig build failed with status: {}", output.status);
    }

    // Link the static library
    println!("cargo:rustc-link-search=native={}/lib", out_dir.display());
    println!("cargo:rustc-link-lib=static=zlob");

    // debug only rebuild information
    println!("cargo:rerun-if-changed=../src/");
    println!("cargo:rerun-if-changed=../build.zig");
    println!("cargo:rerun-if-changed=../include/zlob.h");
}

/// Parse the C header file and generate Rust constants.
/// This ensures the C header is the single source of truth for flag values.
fn generate_flags_from_header(zlob_root: &std::path::Path, out_dir: &PathBuf) {
    let header_path = zlob_root.join("include/zlob.h");
    let file = fs::File::open(&header_path)
        .unwrap_or_else(|e| panic!("Failed to open {}: {}", header_path.display(), e));
    let reader = BufReader::new(file);

    let mut constants = Vec::new();

    // We need to handle multi-line #define macros
    let mut current_define = String::new();
    let mut in_multiline = false;

    for line in reader.lines() {
        let line = line.unwrap();

        if in_multiline {
            current_define.push_str(line.trim());
            if !line.trim_end().ends_with('\\') {
                // End of multi-line define
                in_multiline = false;
                if let Some(constant) = parse_zlob_define(&current_define) {
                    constants.push(constant);
                }
                current_define.clear();
            } else {
                // Remove trailing backslash and continue
                current_define = current_define.trim_end_matches('\\').to_string();
            }
        } else if line.trim_start().starts_with("#define ZLOB_") {
            if line.trim_end().ends_with('\\') {
                // Start of multi-line define
                in_multiline = true;
                current_define = line.trim_end_matches('\\').to_string();
            } else if let Some(constant) = parse_zlob_define(&line) {
                constants.push(constant);
            }
        }
    }

    // Generate Rust code
    let mut rust_code = String::from(
        "// Auto-generated from include/zlob.h - DO NOT EDIT\n\
         // This file is generated by build.rs to ensure flag values match the C header.\n\n",
    );

    for (name, value) in &constants {
        rust_code.push_str(&format!("pub const {}: i32 = {};\n", name, value));
    }

    let output_path = out_dir.join("zlob_flags.rs");
    fs::write(&output_path, rust_code)
        .unwrap_or_else(|e| panic!("Failed to write {}: {}", output_path.display(), e));
}

/// Parse a #define line and extract the constant name and value.
/// Handles expressions like `(1 << 24)` and compound expressions like `(A | B | C)`.
fn parse_zlob_define(line: &str) -> Option<(String, String)> {
    // Match: #define ZLOB_NAME value or #define ZLOB_NAME (expression)
    let line = line.trim();
    if !line.starts_with("#define ZLOB_") {
        return None;
    }

    // Remove #define prefix
    let rest = line.strip_prefix("#define ")?;

    // Split by whitespace to get name and value
    let mut parts = rest.split_whitespace();
    let name = parts.next()?;

    // Skip non-flag defines (like ZLOB_H, ZLOB_DT_*)
    if name == "ZLOB_H" || name.starts_with("ZLOB_DT_") {
        return None;
    }

    // Collect the rest as the value, removing comments
    let value_parts: Vec<&str> = parts.collect();
    let value_str = value_parts.join(" ");

    // Remove C comments /* ... */
    let value_str = if let Some(comment_start) = value_str.find("/*") {
        value_str[..comment_start].trim().to_string()
    } else {
        value_str
    };

    if value_str.is_empty() {
        return None;
    }

    // Evaluate the expression to get an i32 value
    let evaluated = evaluate_c_expr(&value_str)?;

    Some((name.to_string(), evaluated.to_string()))
}

/// Evaluate a simple C expression like `(1 << 24)` or `(A | B | C)`.
/// For compound expressions, we recursively evaluate.
fn evaluate_c_expr(expr: &str) -> Option<i32> {
    let expr = expr.trim().trim_matches(|c| c == '(' || c == ')');

    // Handle bit shift: `1 << N`
    if let Some((left, right)) = expr.split_once("<<") {
        let left: i32 = left.trim().parse().ok()?;
        let right: i32 = right.trim().parse().ok()?;
        return Some(left << right);
    }

    // Handle bitwise OR: `A | B | C`
    if expr.contains('|') {
        let mut result = 0i32;
        for part in expr.split('|') {
            let part = part.trim();
            // For ZLOB_RECOMMENDED which references other ZLOB_ constants
            if part.starts_with("ZLOB_") {
                // We need to know the value of these constants
                // For now, hardcode the known compound constant
                match part {
                    "ZLOB_BRACE" => result |= 1 << 10,
                    "ZLOB_DOUBLESTAR_RECURSIVE" => result |= 1 << 25,
                    "ZLOB_NOSORT" => result |= 1 << 2,
                    "ZLOB_TILDE" => result |= 1 << 12,
                    "ZLOB_TILDE_CHECK" => result |= 1 << 14,
                    _ => return None,
                }
            } else if let Ok(num) = part.parse::<i32>() {
                result |= num;
            } else if let Some(val) = evaluate_c_expr(part) {
                result |= val;
            } else {
                return None;
            }
        }
        return Some(result);
    }

    // Simple integer
    expr.parse().ok()
}

fn rust_target_to_zig(target: &str) -> &'static str {
    match target {
        // Linux
        "x86_64-unknown-linux-gnu" => "x86_64-linux-gnu",
        "x86_64-unknown-linux-musl" => "x86_64-linux-musl",
        "aarch64-unknown-linux-gnu" => "aarch64-linux-gnu",
        "aarch64-unknown-linux-musl" => "aarch64-linux-musl",
        "i686-unknown-linux-gnu" => "x86-linux-gnu",
        "armv7-unknown-linux-gnueabihf" => "arm-linux-gnueabihf",

        // macOS
        "x86_64-apple-darwin" => "x86_64-macos",
        "aarch64-apple-darwin" => "aarch64-macos",

        // Windows
        "x86_64-pc-windows-gnu" => "x86_64-windows-gnu",
        "x86_64-pc-windows-msvc" => "x86_64-windows-msvc",
        "i686-pc-windows-gnu" => "x86-windows-gnu",
        "i686-pc-windows-msvc" => "x86-windows-msvc",
        "aarch64-pc-windows-msvc" => "aarch64-windows-msvc",

        // FreeBSD
        "x86_64-unknown-freebsd" => "x86_64-freebsd",
        "aarch64-unknown-freebsd" => "aarch64-freebsd",

        // Use native for unknown targets
        _ => "native",
    }
}
